{
  "file": "fonts.ts",
  "order": 2,
  "body": {
    "raw": "\n```ts\nexport interface GoogleFont {\n  family: string;\n  variants: string[];\n  subsets: string[];\n  version: string;\n  lastModified: string;\n  files: Record<string, string>;\n  category: string;\n  kind: string;\n}\n\nconst API_KEY = process.env.NEXT_PUBLIC_GOOGLE_FONTS_API_KEY;\nconst API_URL = \"https://www.googleapis.com/webfonts/v1/webfonts\";\n\n// Cache for loaded font stylesheets\nconst loadedFonts = new Set<string>();\n\n// Cache for the Google Fonts API response\nlet fontsCache: GoogleFont[] | null = null;\nlet fontsCacheTimestamp: number | null = null;\nconst CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours\n\nexport async function fetchGoogleFonts(): Promise<GoogleFont[]> {\n  // Check if we have a valid cache\n  if (\n    fontsCache &&\n    fontsCacheTimestamp &&\n    Date.now() - fontsCacheTimestamp < CACHE_DURATION\n  ) {\n    return fontsCache;\n  }\n\n  if (!API_KEY) {\n    throw new Error(\"Google Fonts API key is not configured\");\n  }\n\n  try {\n    const response = await fetch(`${API_URL}?key=${API_KEY}&sort=popularity`);\n    if (!response.ok) {\n      throw new Error(\"Failed to fetch Google Fonts\");\n    }\n    const data = await response.json();\n    fontsCache = data.items;\n    fontsCacheTimestamp = Date.now();\n    return data.items;\n  } catch (error) {\n    // If fetch fails and we have a cache, return it even if expired\n    if (fontsCache) {\n      return fontsCache;\n    }\n    console.error(\"Error fetching Google Fonts:\", error);\n    throw error;\n  }\n}\n\nexport function getFontUrl(font: GoogleFont, variant = \"regular\"): string {\n  const fontFamily = font.family.replace(/\\s+/g, \"+\");\n  const fontVariant = variant === \"regular\" ? \"400\" : variant;\n  return `https://fonts.googleapis.com/css2?family=${fontFamily}:wght@${fontVariant}&display=swap`;\n}\n\nexport async function loadFont(\n  fontFamily: string,\n  variant = \"regular\"\n): Promise<void> {\n  if (loadedFonts.has(fontFamily)) {\n    return;\n  }\n\n  return new Promise((resolve, reject) => {\n    const link = document.createElement(\"link\");\n    link.href = getFontUrl({ family: fontFamily } as GoogleFont, variant);\n    link.rel = \"stylesheet\";\n\n    link.onload = () => {\n      loadedFonts.add(fontFamily);\n      resolve();\n    };\n\n    link.onerror = () => {\n      reject(new Error(`Failed to load font: ${fontFamily}`));\n    };\n\n    document.head.appendChild(link);\n  });\n}\n\nexport interface FontPickerProps {\n  onFontSelect?: (font: GoogleFont) => void;\n  value?: string;\n}\n\nexport const FONT_CATEGORIES = [\n  \"serif\",\n  \"sans-serif\",\n  \"display\",\n  \"handwriting\",\n  \"monospace\",\n] as const;\n\nexport type FontCategory = (typeof FONT_CATEGORIES)[number];\n\nexport const FONT_WEIGHTS = [\n  \"100\",\n  \"200\",\n  \"300\",\n  \"400\",\n  \"500\",\n  \"600\",\n  \"700\",\n  \"800\",\n  \"900\",\n] as const;\n\nexport type FontWeight = (typeof FONT_WEIGHTS)[number];\n```\n",
    "code": "var Component=(()=>{var ae=Object.create;var _=Object.defineProperty;var se=Object.getOwnPropertyDescriptor;var ie=Object.getOwnPropertyNames;var ce=Object.getPrototypeOf,le=Object.prototype.hasOwnProperty;var T=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),fe=(r,t)=>{for(var i in t)_(r,i,{get:t[i],enumerable:!0})},S=(r,t,i,m)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let c of ie(t))!le.call(r,c)&&c!==i&&_(r,c,{get:()=>t[c],enumerable:!(m=se(t,c))||m.enumerable});return r};var ue=(r,t,i)=>(i=r!=null?ae(ce(r)):{},S(t||!r||!r.__esModule?_(i,\"default\",{value:r,enumerable:!0}):i,r)),de=r=>S(_({},\"__esModule\",{value:!0}),r);var j=T((ge,x)=>{x.exports=React});var I=T(v=>{\"use strict\";(function(){function r(e){if(e==null)return null;if(typeof e==\"function\")return e.$$typeof===ee?null:e.displayName||e.name||null;if(typeof e==\"string\")return e;switch(e){case E:return\"Fragment\";case X:return\"Profiler\";case K:return\"StrictMode\";case B:return\"Suspense\";case Z:return\"SuspenseList\";case J:return\"Activity\"}if(typeof e==\"object\")switch(typeof e.tag==\"number\"&&console.error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"),e.$$typeof){case V:return\"Portal\";case H:return(e.displayName||\"Context\")+\".Provider\";case z:return(e._context.displayName||\"Context\")+\".Consumer\";case q:var n=e.render;return e=e.displayName,e||(e=n.displayName||n.name||\"\",e=e!==\"\"?\"ForwardRef(\"+e+\")\":\"ForwardRef\"),e;case Q:return n=e.displayName||null,n!==null?n:r(e.type)||\"Memo\";case R:n=e._payload,e=e._init;try{return r(e(n))}catch{}}return null}function t(e){return\"\"+e}function i(e){try{t(e);var n=!1}catch{n=!0}if(n){n=console;var o=n.error,s=typeof Symbol==\"function\"&&Symbol.toStringTag&&e[Symbol.toStringTag]||e.constructor.name||\"Object\";return o.call(n,\"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",s),t(e)}}function m(e){if(e===E)return\"<>\";if(typeof e==\"object\"&&e!==null&&e.$$typeof===R)return\"<...>\";try{var n=r(e);return n?\"<\"+n+\">\":\"<...>\"}catch{return\"<...>\"}}function c(){var e=O.A;return e===null?null:e.getOwner()}function y(){return Error(\"react-stack-top-frame\")}function U(e){if(A.call(e,\"key\")){var n=Object.getOwnPropertyDescriptor(e,\"key\").get;if(n&&n.isReactWarning)return!1}return e.key!==void 0}function $(e,n){function o(){F||(F=!0,console.error(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",n))}o.isReactWarning=!0,Object.defineProperty(e,\"key\",{get:o,configurable:!0})}function L(){var e=r(this.type);return N[e]||(N[e]=!0,console.error(\"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\")),e=this.props.ref,e!==void 0?e:null}function W(e,n,o,s,l,f,u,g){return o=f.ref,e={$$typeof:w,type:e,key:n,props:f,_owner:l},(o!==void 0?o:null)!==null?Object.defineProperty(e,\"ref\",{enumerable:!1,get:L}):Object.defineProperty(e,\"ref\",{enumerable:!1,value:null}),e._store={},Object.defineProperty(e._store,\"validated\",{configurable:!1,enumerable:!1,writable:!0,value:0}),Object.defineProperty(e,\"_debugInfo\",{configurable:!1,enumerable:!1,writable:!0,value:null}),Object.defineProperty(e,\"_debugStack\",{configurable:!1,enumerable:!1,writable:!0,value:u}),Object.defineProperty(e,\"_debugTask\",{configurable:!1,enumerable:!1,writable:!0,value:g}),Object.freeze&&(Object.freeze(e.props),Object.freeze(e)),e}function M(e,n,o,s,l,f,u,g){var a=n.children;if(a!==void 0)if(s)if(ne(a)){for(s=0;s<a.length;s++)k(a[s]);Object.freeze&&Object.freeze(a)}else console.error(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");else k(a);if(A.call(n,\"key\")){a=r(e);var d=Object.keys(n).filter(function(oe){return oe!==\"key\"});s=0<d.length?\"{key: someKey, \"+d.join(\": ..., \")+\": ...}\":\"{key: someKey}\",C[a+s]||(d=0<d.length?\"{\"+d.join(\": ..., \")+\": ...}\":\"{}\",console.error(`A props object containing a \"key\" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />`,s,a,d,a),C[a+s]=!0)}if(a=null,o!==void 0&&(i(o),a=\"\"+o),U(n)&&(i(n.key),a=\"\"+n.key),\"key\"in n){o={};for(var h in n)h!==\"key\"&&(o[h]=n[h])}else o=n;return a&&$(o,typeof e==\"function\"?e.displayName||e.name||\"Unknown\":e),W(e,a,f,l,c(),o,u,g)}function k(e){typeof e==\"object\"&&e!==null&&e.$$typeof===w&&e._store&&(e._store.validated=1)}var b=j(),w=Symbol.for(\"react.transitional.element\"),V=Symbol.for(\"react.portal\"),E=Symbol.for(\"react.fragment\"),K=Symbol.for(\"react.strict_mode\"),X=Symbol.for(\"react.profiler\");Symbol.for(\"react.provider\");var z=Symbol.for(\"react.consumer\"),H=Symbol.for(\"react.context\"),q=Symbol.for(\"react.forward_ref\"),B=Symbol.for(\"react.suspense\"),Z=Symbol.for(\"react.suspense_list\"),Q=Symbol.for(\"react.memo\"),R=Symbol.for(\"react.lazy\"),J=Symbol.for(\"react.activity\"),ee=Symbol.for(\"react.client.reference\"),O=b.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,A=Object.prototype.hasOwnProperty,ne=Array.isArray,P=console.createTask?console.createTask:function(){return null};b={\"react-stack-bottom-frame\":function(e){return e()}};var F,N={},re=b[\"react-stack-bottom-frame\"].bind(b,y)(),te=P(m(y)),C={};v.Fragment=E,v.jsxDEV=function(e,n,o,s,l,f){var u=1e4>O.recentlyCreatedOwnerStacks++;return M(e,n,o,s,l,f,u?Error(\"react-stack-top-frame\"):re,u?P(m(e)):te)}})()});var G=T((Te,D)=>{\"use strict\";D.exports=I()});var _e={};fe(_e,{default:()=>be,frontmatter:()=>me});var p=ue(G()),me={file:\"fonts.ts\",order:2};function Y(r){let t=Object.assign({pre:\"pre\",code:\"code\"},r.components);return(0,p.jsxDEV)(t.pre,{children:(0,p.jsxDEV)(t.code,{className:\"language-ts\",children:`export interface GoogleFont {\n  family: string;\n  variants: string[];\n  subsets: string[];\n  version: string;\n  lastModified: string;\n  files: Record<string, string>;\n  category: string;\n  kind: string;\n}\n\nconst API_KEY = process.env.NEXT_PUBLIC_GOOGLE_FONTS_API_KEY;\nconst API_URL = \"https://www.googleapis.com/webfonts/v1/webfonts\";\n\n// Cache for loaded font stylesheets\nconst loadedFonts = new Set<string>();\n\n// Cache for the Google Fonts API response\nlet fontsCache: GoogleFont[] | null = null;\nlet fontsCacheTimestamp: number | null = null;\nconst CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours\n\nexport async function fetchGoogleFonts(): Promise<GoogleFont[]> {\n  // Check if we have a valid cache\n  if (\n    fontsCache &&\n    fontsCacheTimestamp &&\n    Date.now() - fontsCacheTimestamp < CACHE_DURATION\n  ) {\n    return fontsCache;\n  }\n\n  if (!API_KEY) {\n    throw new Error(\"Google Fonts API key is not configured\");\n  }\n\n  try {\n    const response = await fetch(\\`\\${API_URL}?key=\\${API_KEY}&sort=popularity\\`);\n    if (!response.ok) {\n      throw new Error(\"Failed to fetch Google Fonts\");\n    }\n    const data = await response.json();\n    fontsCache = data.items;\n    fontsCacheTimestamp = Date.now();\n    return data.items;\n  } catch (error) {\n    // If fetch fails and we have a cache, return it even if expired\n    if (fontsCache) {\n      return fontsCache;\n    }\n    console.error(\"Error fetching Google Fonts:\", error);\n    throw error;\n  }\n}\n\nexport function getFontUrl(font: GoogleFont, variant = \"regular\"): string {\n  const fontFamily = font.family.replace(/\\\\s+/g, \"+\");\n  const fontVariant = variant === \"regular\" ? \"400\" : variant;\n  return \\`https://fonts.googleapis.com/css2?family=\\${fontFamily}:wght@\\${fontVariant}&display=swap\\`;\n}\n\nexport async function loadFont(\n  fontFamily: string,\n  variant = \"regular\"\n): Promise<void> {\n  if (loadedFonts.has(fontFamily)) {\n    return;\n  }\n\n  return new Promise((resolve, reject) => {\n    const link = document.createElement(\"link\");\n    link.href = getFontUrl({ family: fontFamily } as GoogleFont, variant);\n    link.rel = \"stylesheet\";\n\n    link.onload = () => {\n      loadedFonts.add(fontFamily);\n      resolve();\n    };\n\n    link.onerror = () => {\n      reject(new Error(\\`Failed to load font: \\${fontFamily}\\`));\n    };\n\n    document.head.appendChild(link);\n  });\n}\n\nexport interface FontPickerProps {\n  onFontSelect?: (font: GoogleFont) => void;\n  value?: string;\n}\n\nexport const FONT_CATEGORIES = [\n  \"serif\",\n  \"sans-serif\",\n  \"display\",\n  \"handwriting\",\n  \"monospace\",\n] as const;\n\nexport type FontCategory = (typeof FONT_CATEGORIES)[number];\n\nexport const FONT_WEIGHTS = [\n  \"100\",\n  \"200\",\n  \"300\",\n  \"400\",\n  \"500\",\n  \"600\",\n  \"700\",\n  \"800\",\n  \"900\",\n] as const;\n\nexport type FontWeight = (typeof FONT_WEIGHTS)[number];\n`},void 0,!1,{fileName:\"/Users/vinodpatidar/Desktop/shadcn-font-picker/content/snippets/_mdx_bundler_entry_point-74d9e6bb-24dd-4338-bb71-5a8a8e8889cd.mdx\",lineNumber:6,columnNumber:1},this)},void 0,!1,{fileName:\"/Users/vinodpatidar/Desktop/shadcn-font-picker/content/snippets/_mdx_bundler_entry_point-74d9e6bb-24dd-4338-bb71-5a8a8e8889cd.mdx\",lineNumber:6,columnNumber:1},this)}function pe(r={}){let{wrapper:t}=r.components||{};return t?(0,p.jsxDEV)(t,Object.assign({},r,{children:(0,p.jsxDEV)(Y,r,void 0,!1,{fileName:\"/Users/vinodpatidar/Desktop/shadcn-font-picker/content/snippets/_mdx_bundler_entry_point-74d9e6bb-24dd-4338-bb71-5a8a8e8889cd.mdx\"},this)}),void 0,!1,{fileName:\"/Users/vinodpatidar/Desktop/shadcn-font-picker/content/snippets/_mdx_bundler_entry_point-74d9e6bb-24dd-4338-bb71-5a8a8e8889cd.mdx\"},this):Y(r)}var be=pe;return de(_e);})();\n/*! Bundled license information:\n\nreact/cjs/react-jsx-dev-runtime.development.js:\n  (**\n   * @license React\n   * react-jsx-dev-runtime.development.js\n   *\n   * Copyright (c) Meta Platforms, Inc. and affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n*/\n;return Component;"
  },
  "_id": "snippets/fonts.mdx",
  "_raw": {
    "sourceFilePath": "snippets/fonts.mdx",
    "sourceFileName": "fonts.mdx",
    "sourceFileDir": "snippets",
    "contentType": "mdx",
    "flattenedPath": "snippets/fonts"
  },
  "type": "Snippet",
  "slug": "fonts"
}